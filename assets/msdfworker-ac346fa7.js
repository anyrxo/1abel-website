(function(){"use strict";const et=/\n/,nt=/[ \t]/;function st(k,i,o){for(let c=0;c<k.kerning.length;c++){const m=k.kerning[c];if(m.unicode1===i&&m.unicode2===o)return m.advance}return 0}onmessage=k=>{const{font:i,options:o}=k.data;let c=o.text||"";const m=o.width||1/0,R=o.align||"left",w=o.size||1,it=o.letterSpacing||0,ot=o.lineHeight||1.4,X=o.wordSpacing||0,Y=o.wordBreak||!1,lt=o.baseOffset||0,g=w/i.metrics.lineHeight;c=c.replace(/\xA0/g," ");const p=c.replace(/[ \n]/g,"").length,s={index:new Uint16Array(p*6),position:new Float32Array(p*4*3),uv:new Float32Array(p*4*2),centr:new Float32Array(p*4*3),uvMask:new Float32Array(p*4*4),textWeights:new Float32Array(p*4*2),lineWeights:new Float32Array(p*4*3),maxLineHeight:-1/0,maxUVDisp:-1/0};for(let t=0;t<p;t++)s.index.set([t*4,t*4+2,t*4+1,t*4+1,t*4+2,t*4+3],t*6);const d=[];let l=0,x=0,u=0;function M(){const t={width:0,glyphs:[]};return d.push(t),x=l,u=0,t}let e=M();for(;l<c.length;){let t=c[l];if(!e.width&&nt.test(t)){l++,x=l,u=0;continue}if(et.test(t)){e.glyphs.length&&e.glyphs[e.glyphs.length-1][0].isWhitespace&&(e.width-=X*w+e.glyphs[e.glyphs.length-1][0].advance*g,e.glyphs.pop()),l++,e=M();continue}let n=i.glyphs[t];if(i.glyphs[t]||(console.warn(`${t} is not present in the MSDF font atlas. Using "${i.placeholderChar}" instead.`),t=i.placeholderChar,n=i.glyphs[t]),e.glyphs.length){const h=e.glyphs[e.glyphs.length-1][0],b=st(i,n.unicode,h.unicode)*g;e.width+=b,u+=b}e.glyphs.push([n,e.width]);let a=0;if(n.isWhitespace?(x=l,u=0,a+=X*w):a+=it*w,a+=n.advance*g,e.width+=a,u+=a,e.width>m){if(Y&&e.glyphs.length>1){e.width-=a,e.glyphs.pop(),e=M();continue}else if(!Y&&u!==e.width){const h=l-x+1;e.glyphs.splice(-h,h),l=x,e.width-=u,e=M();continue}}l++}e.width||d.pop();const _=i.atlas.width,q=i.atlas.height;let W=lt*w,f=0,$=-1,v=-1;const J=d.length-1,Q=[];d.forEach(t=>{$+=t.glyphs.length,v++;let n=0;t.glyphs.forEach(a=>{a[0].isWhitespace&&(v++,n++)}),Q.push(n)});const at=$<1?0:1/$,ht=v<1?0:1/v,ct=J<1?0:1/J,rt=d.map(t=>{const n=t.glyphs.length-1;return n<1?0:1/n}),pt=Q.map(t=>t<1?0:1/t);let Z=-1,K=0;for(let t=0;t<d.length;t++){const n=d[t],a=t*ct;for(let h=0,b=0;h<n.glyphs.length;h++){const r=n.glyphs[h][0];let y=n.glyphs[h][1];if(R==="center"?y-=n.width*.5:R==="right"&&(y-=n.width),Z++,r.isWhitespace){K++,b++;continue}const L=r.planeBounds.bottom*g,B=r.planeBounds.left*g,P=r.planeBounds.right*g,S=r.planeBounds.top*g;s.position.set([y+B,W+L,0,y+B,W+S,0,y+P,W+L,0,y+P,W+S,0],f*4*3),s.maxLineHeight=Math.max(s.maxLineHeight,Math.abs(S)+Math.abs(L));const A=y+B+(Math.abs(B)+Math.abs(P))*.5,F=W+L+(Math.abs(L)+Math.abs(S))*.5;s.centr.set([A,F,0,A,F,0,A,F,0,A,F,0],f*4*3);const H=r.atlasBounds.left/_,N=r.atlasBounds.right/_,U=r.atlasBounds.bottom/q,C=r.atlasBounds.top/q;s.uv.set([H,U,H,C,N,U,N,C],f*4*2),s.maxUVDisp=Math.max(Math.max(s.maxUVDisp,N-H),C-U);const D=H,G=N,I=U,O=C;s.uvMask.set([D,G,I,O,D,G,I,O,D,G,I,O,D,G,I,O],f*4*4);const T=Z*at,E=K*ht;s.textWeights.set([T,E,T,E,T,E,T,E],f*4*2);const V=rt[t]*h,j=pt[t]*b,z=a;s.lineWeights.set([V,j,z,V,j,z,V,j,z,V,j,z],f*4*3),f++}K++,W-=w*ot}const tt=[];Object.keys(s).forEach(t=>{s[t].buffer&&tt.push(s[t].buffer)}),postMessage({buffers:s},tt)}})();
